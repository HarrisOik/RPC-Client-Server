/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "vect.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>

void error(char *msg)
{
    perror(msg);
    exit(1);
}

int
main (int argc, char *argv[])
{
	char *host;
	int sockfd, newsockfd, portno, clilen, n, done, option;
	int *vector_a, *vector_b;
	float r;
	pid_t procId;
    struct sockaddr_in serv_addr, cli_addr;
    unsigned int children = 0;

	if (argc < 3) {		//Έλεγχος σωστής εκτέλεσης
		printf ("usage: %s rpc_server_host port\n", argv[0]);
		exit (1);
	}

    sockfd = socket(AF_INET, SOCK_STREAM, 0);		//Δημιουργία socket
    if (sockfd < 0)
        error("ERROR opening socket!");	

	bzero((char *) &serv_addr, sizeof(serv_addr));
	host = argv[1];
	portno = atoi(argv[2]);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(portno);
    serv_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sockfd, (struct sockaddr *) &serv_addr, sizeof(serv_addr)) < 0)		//Δέσμευση διεύθυνσης για το socket
        error("ERROR on binding!");

    listen(sockfd, 5);		//Αναμονή σύνδεσης πελάτη

    for (;;)
    {
        printf("Waiting for a connection...\n");
        clilen = sizeof(cli_addr);
        newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);		//Αποδοχή πελάτη
        if (newsockfd < 0)
            error("ERROR on accept!");
        
        if (fork() == 0)		//Δημιουργία διεργασίας παιδιού για την εξυπηρέτηση του πελάτη
        {
            close (sockfd);
            printf("Connected.\n");
            done = 0;
			CLIENT *clnt;
			float  *result_1;
			vectors  mag_1_arg;
			int  *result_2;
			vector_pair  dotprod_1_arg;
			results_3  *result_3;
			vector_pair  vecavg_1_arg;
			results_4  *result_4;
			make_vector  newvec_1_arg;
			float avg[2];
			float *new_vector;
		#ifndef	DEBUG
			clnt = clnt_create (host, VECT_PROG, VECT_VERS, "udp");
			if (clnt == NULL) {
				clnt_pcreateerror (host);
				exit (1);
			}
		#endif	/* DEBUG */			
            do
            {
                recv(newsockfd, &option, sizeof(int), 0);		//Αποδοχή επιλογής από τον πελάτη

                switch (option)
                {
                case 1:		//Λογική του μέτρου διανύσματος
                    recv(newsockfd, &n, sizeof(int), 0);
                    vector_a = malloc(sizeof(int) * n);
                    recv(newsockfd, vector_a, (sizeof(int)*n), 0);
                    
					mag_1_arg.n = n;
					mag_1_arg.vector.vector_len = n;
					mag_1_arg.vector.vector_val = malloc(sizeof(int) * n);

					for (int i = 0; i < n; i++)
						mag_1_arg.vector.vector_val[i] = vector_a[i];

					result_1 = mag_1(&mag_1_arg, clnt);
					if (result_1 == (float *) NULL) {
						clnt_perror (clnt, "call failed");
					}

					send(newsockfd, result_1, sizeof(float), 0);

                    free(vector_a);
					free(mag_1_arg.vector.vector_val);
                    break;
                
                case 2:		//Λογική εσωτερικού γινομένου διανυσμάτων
                    recv(newsockfd, &n, sizeof(int), 0);
                    vector_a = malloc(sizeof(int) * n);
                    vector_b = malloc(sizeof(int) * n);
                    recv(newsockfd, vector_a, (sizeof(int)*n), 0);
                    recv(newsockfd, vector_b, (sizeof(int)*n), 0);

					dotprod_1_arg.vector_a.n = n;
					dotprod_1_arg.vector_b.n = n;
					dotprod_1_arg.vector_a.vector.vector_len = n;
					dotprod_1_arg.vector_b.vector.vector_len = n;
					dotprod_1_arg.vector_a.vector.vector_val = malloc(sizeof(int) * n);
					dotprod_1_arg.vector_b.vector.vector_val = malloc(sizeof(int) * n);

					for (int i = 0; i < n; i++)
					{
						dotprod_1_arg.vector_a.vector.vector_val[i] = vector_a[i];
						dotprod_1_arg.vector_b.vector.vector_val[i] = vector_b[i];
					}

					result_2 = dotprod_1(&dotprod_1_arg, clnt);
					if (result_2 == (int *) NULL) {
						clnt_perror (clnt, "call failed");
					}

					send(newsockfd, result_2, sizeof(int), 0);

                    free(vector_a);
                    free(vector_b);
					free(dotprod_1_arg.vector_a.vector.vector_val);
					free(dotprod_1_arg.vector_b.vector.vector_val);
                    break;

                case 3:		//Λογική της μέσης τιμής των διανυσμάτων
                    recv(newsockfd, &n, sizeof(int), 0);
                    vector_a = malloc(sizeof(int) * n);
                    vector_b = malloc(sizeof(int) * n);
                    recv(newsockfd, vector_a, (sizeof(int)*n), 0);
                    recv(newsockfd, vector_b, (sizeof(int)*n), 0);
                   
					vecavg_1_arg.vector_a.n = n;
					vecavg_1_arg.vector_b.n = n;
					vecavg_1_arg.vector_a.vector.vector_len = n;
					vecavg_1_arg.vector_b.vector.vector_len = n;
					vecavg_1_arg.vector_a.vector.vector_val = malloc(sizeof(int) * n);
					vecavg_1_arg.vector_b.vector.vector_val = malloc(sizeof(int) * n);

					for (int i = 0; i < n; i++)
					{
						vecavg_1_arg.vector_a.vector.vector_val[i] = vector_a[i];
						vecavg_1_arg.vector_b.vector.vector_val[i] = vector_b[i];
					}

					result_3 = vecavg_1(&vecavg_1_arg, clnt);
					if (result_3 == (results_3 *) NULL) {
						clnt_perror (clnt, "call failed");
					}

					avg[0] = result_3->avg.avg_val[0];
					avg[1] = result_3->avg.avg_val[1];

					send(newsockfd, avg, (sizeof(float) * 2), 0);

                    free(vector_a);
                    free(vector_b);
					free(vecavg_1_arg.vector_a.vector.vector_val);
					free(vecavg_1_arg.vector_b.vector.vector_val);
                    break;

                case 4:		//Λογική της δημιουργίας καινούργιου διανύσματος
                    recv(newsockfd, &n, sizeof(int), 0);
                    vector_a = malloc(sizeof(int) * n);
                    vector_b = malloc(sizeof(int) * n);
                    recv(newsockfd, vector_a, (sizeof(int)*n), 0);
                    recv(newsockfd, vector_b, (sizeof(int)*n), 0);
                    recv(newsockfd, &r, sizeof(float), 0);

					newvec_1_arg.r = r;
					newvec_1_arg.pair.vector_a.n = n;
					newvec_1_arg.pair.vector_b.n = n;
					newvec_1_arg.pair.vector_a.vector.vector_len = n;
					newvec_1_arg.pair.vector_b.vector.vector_len = n;
					newvec_1_arg.pair.vector_a.vector.vector_val = malloc(sizeof(int) * n);
					newvec_1_arg.pair.vector_b.vector.vector_val = malloc(sizeof(int) * n);

					for (int i = 0; i < n; i++)
					{
						newvec_1_arg.pair.vector_a.vector.vector_val[i] = vector_a[i];
						newvec_1_arg.pair.vector_b.vector.vector_val[i] = vector_b[i];
					}

					result_4->new_vector.new_vector_len = n;
					result_4->new_vector.new_vector_val = malloc(sizeof(float) * n);

					result_4 = newvec_1(&newvec_1_arg, clnt);
					if (result_4 == (results_4 *) NULL) {
						clnt_perror (clnt, "call failed");
					}

					new_vector = malloc(sizeof(float) * n);

					for (int i = 0; i < n; i++)
						new_vector[i] = result_4->new_vector.new_vector_val[i];

					send(newsockfd, new_vector, (sizeof(float) * n), 0);

                    free(vector_a);
                    free(vector_b);
					free(newvec_1_arg.pair.vector_a.vector.vector_val);
					free(newvec_1_arg.pair.vector_b.vector.vector_val);
					free(result_4->new_vector.new_vector_val);
					free(new_vector);
                    break;
                
                default:
                    done = 1;
				#ifndef	DEBUG
					clnt_destroy (clnt);
				#endif	 /* DEBUG */
                    break;
                }
            } while (!done);
            exit(0);
        }
        close(newsockfd);
        children++;
        while (children)
        {
            procId = waitpid((pid_t) -1, NULL, WNOHANG);
            if (procId < 0)
                error("waitpid error!");
            else if (procId == 0)
                break;
            else
                printf("Gathered\n");
        }
    }
	return 0;
}
